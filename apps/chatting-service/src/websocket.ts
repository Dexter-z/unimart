import redis from "@packages/libs/redis";
import { Server as HttpServer } from "http"
import { kafka } from "@packages/utils/kafka";
import { WebSocketServer, WebSocket } from "ws";

const producer = kafka.producer();
const connectedUsers: Map<string, WebSocket> = new Map();
const unseenCounts: Map<string, number> = new Map();

type IncomingMessage = {
    type?: string;
    fromUserId: string;
    toUserId: string;
    messageBody: string;
    conversationId: string;
    senderType: string;
}

export async function createWebSocketServer(server: HttpServer) {
    //Web socket server
    const wss = new WebSocketServer({ server });

    await producer.connect()
    console.log("WebSocket server kafka producer connected")

    wss.on("connection", (ws: WebSocket) => {
        console.log("New websocket connection established");
        let registeredUserId: string | null = null;

        ws.on("message", async (rawMessage) => {
            try {
                const messageStr = rawMessage.toString();

                //Register the user on first plain message (Non json)
                if (!registeredUserId && !messageStr.startsWith("{")) {
                    registeredUserId = messageStr;
                    connectedUsers.set(registeredUserId, ws);
                    console.log(`User registered: ${registeredUserId}`);

                    const isSeller = registeredUserId.startsWith("seller_")
                    const redisKey = isSeller ? `online:seller:${registeredUserId.replace("seller_", "")}` : `online:user:${registeredUserId}`;
                    await redis.set(redisKey, "1");
                    await redis.expire(redisKey, 300)
                    return;
                }

                //Process json message
                const raw = JSON.parse(messageStr);
                // Backward compatibility: clients might send fromSellerId; normalize to fromUserId
                const data: IncomingMessage = {
                    ...raw,
                    fromUserId: raw.fromUserId || raw.fromSellerId, // prioritize standard key
                };

                //If it is seen update
                if (data.type === "MARK_AS_SEEN" && registeredUserId) {
                    const seenKey = `${registeredUserId}_${data.conversationId}`;
                    unseenCounts.set(seenKey, 0);
                    return
                }

                //Regular message
                const { fromUserId, toUserId, messageBody, conversationId, senderType } = data;
                if(!fromUserId){
                    console.error("Missing fromUserId in message", raw);
                    return;
                }

                if (!data || !toUserId || !messageBody || !conversationId) {
                    console.error("Invalid message format", data);
                    return;
                }

                const now = new Date().toISOString();

                const messagePayload = {
                    senderId: fromUserId,
                    content: messageBody,
                    conversationId,
                    senderType,
                    createdAt: now
                }

                const messageEvent = JSON.stringify({
                    type: "NEW_MESSAGE",
                    payload: messagePayload
                })

                const receiverKey = senderType === "user" ? `seller_${toUserId}` : `user_${toUserId}`;

                const senderKey = senderType === "user" ? `user_${fromUserId}` : `seller_${fromUserId}`;

                //Update unseen counts
                const unseenKey = `${receiverKey}_${conversationId}`;
                const prevCount = unseenCounts.get(unseenKey) || 0;
                unseenCounts.set(unseenKey, prevCount + 1);

                //Send the message to receiver
                const receiverSocket = connectedUsers.get(receiverKey);
                if (receiverSocket && receiverSocket.readyState === WebSocket.OPEN) {
                    receiverSocket.send(messageEvent);

                    //Also send unseen count
                    receiverSocket.send(JSON.stringify({
                        type: "UNSEEN_COUNT_UPDATE",
                        payload: {
                            conversationId,
                            count: prevCount + 1
                        }
                    }));

                    console.log(`Delivered Message to ${receiverKey} `);
                } else {
                    console.log(`User ${receiverKey} is offline. Message queued`);
                }
                
                //Echo to sender
                const senderSocket = connectedUsers.get(senderKey);
                if (senderSocket && senderSocket.readyState === WebSocket.OPEN) {
                    senderSocket.send(messageEvent);

                    console.log(`Echoed message to sender ${senderKey}`);
                }

                //Push to kafka
                //Add the topic to kafka
                await producer.send({
                    topic: "chat.new_message",
                    messages: [
                        {
                            key: conversationId,
                            value: JSON.stringify(messagePayload)
                        }
                    ]
                })

                console.log(`Message Queued to kafka: ${conversationId}`)

            } catch (error) {
                console.error("Error processing message", error);
            }
        })

        ws.on("close", async() => {
            if(registeredUserId) {
                connectedUsers.delete(registeredUserId)
                console.log(`Disconnected user ${registeredUserId}`)

                const isSeller = registeredUserId.startsWith("seller_")
                const redisKey = isSeller ? `online:seller:${registeredUserId.replace("seller_", "")}` : `online:user:${registeredUserId}`;
                await redis.del(redisKey);
            }
        })

        ws.on("error", async (error) => {
            console.error("WebSocket error:", error);
        })
    })

    console.log("Websocket server ready")
}